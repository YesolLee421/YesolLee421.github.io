---
title: "[블록체인] 6주차_블록체인과 암호기술 1"
categories:
  - BlockChain

comments : true
---
*이 내용은 K-MOOC [알기쉬운블록체인] 강의를 듣고 정리한 내용입니다.*
<br>

[알기쉬운블록체인]: http://www.kmooc.kr/courses/course-v1:SJCU+SJCU01+2019_2/courseware/145ba5714d1246c1b65fe1b081d52db0/e1af1659e74343579fe5727acdfcfbc7/?child=last

<br>

# 데이터의 신뢰성
## 디지털 데이터의 신뢰성이란?
### 1. 디지털 데이터의 특징
- 디지털 데이터란? 컴퓨터가 이해할 수 있는 언어로 변조해서(`부호화`,`encoding`) 디지털 형태로 가공된 정보
- 복제 용이->변조, 변경 용이
- '원본에 대한 신뢰성을 어떻게 확보할 수 있을까?'
- 대부분 양이 방대 & `비가독성` (컴퓨터가 이해할 수 있는 고유 언어로 부호화되어 인간이 이해하기 힘듦)<br>

### 2. 디지털 데이터의 신뢰성
- 원본에 대한 복제가 굉장히 용이하니 사본을 쉽게 만들 수 있다.
- 사본이 원본과 값이 같으면 사본 또한 원본이 된다.
- 즉 '원본' 이라는 의미는 '변조되지 않았음'을 의미함
- A, B 중 어느 것이 원본인가?
  - 두 데이터를 위에서부터 순차적으로 전부 비교: 양이 적을 때 가능
  - 그러나 양이 많으면?<br>


### 3. 매우 큰 두 디지털 데이터 비교하기: 검증값 (validation value)
- 주어진 원본값에 대한 검증값이 주어지고, 해당 값을 공개함
- 용량 큰 프로그램 다운 받을 때, 원본 프로그램과 동일한지 확인하는 절차
- 프로그램 다운받은 후, 원본 프로그램의 연산을 통해 계산한 검증값과 원본 사이트에서 공개한 검증값과 비교해서 변조되지 않았음을 식별함
- 같은 계산과정(프로그램)이라면 같은 입력값에 대해 같은 출력값(검증값)을 내보냄
- 장점: 전체 데이터에 비해 검증값은 일정한 크기의 작은 값이 되도록 유지
- 따라서 디지털 데이터: `디지털데이터` + `검증값`<br>

### 4. 검증값 예시: 통신 상 오류 검출을 위한 CRC 값
- 통신 상 오류 발생해서 발신자가 전달한 데이터나 메시지가 수신자에게 도착했을 때 일부 변조가 일어날 가능성이 있다ㅏ.
- 이런 오류를 검출하기 위해 패킷(packit) 정보 뒤에 CRC값을 많이 붙인다.
- CRC (Cyclic Redundancy Check)
- 통신 상 오류를 빠르게 검출하기 위해 사용하는 검증값
- 검증: 패킷 수신자는 패킷으로부터 유도된(계산된) CRC 값과 패킷 뒤에 붙어 온 CRC 값을 비교함으로서 '원본 패킷이 잘 왔는가?'를 검증함<br>

- 그러나 CRC 값 만으로 `무결성`을 주장하기엔 부족함: 패킷과 CRC 값이 이미 주어 진 상황에서 변조시킨 패킷이 우연히 동일한 CRC 값을 내놓을 경우 있음
- 따라서 실제 검증값: 주어 진 입력값 변조해서 유효한 CRC 값을 만들기 어렵도록 설계하는 것이 주요 이슈<br>

## 데이터와 검증값
### 1. 데이터로 검증값 만드는 합리적 방법
- 검증값: 주어진 데이터를 가지고 **어떠한 과정**을 통해 가공한 출력값
- 함수: 검증값을 만들어내는 과정
- `입력값` (디지털 데이터) -> `함수`(계산과정) -> `검증값`(가공된 출력값)<br>

### 2. 함수의 역할
- 검증값: 방대한 원본 데이터보다 작아서 비교하기 쉽고 빠름
- 원본 데이터가 같으면 같은 검증값 출력해야 검증의 유효성 확인 가능<br>

1. 입력 데이터를 축약한다.
2. 동일한 입력값이 들어가면 동일한 출력값이 나온다.<br>

- 함수에 들어갈 입력 및 출력의 크기
  - 입력값: 무한대의 입력값 가능
  - 출력값: 입력값 길이와 상관 없이 동일한 길이의 출력값 필요
  - 예시) 자연수를 받아서 일정 길이의 검증값 출력하기
    1. 입력값: 자연수 전체 집합 (무한대 가능)
    2. 함수: 입력값을 *13으로 나눴을 때 나머지 값 계산*
    3. 출력값: 0부터 12까지 정수만 가능 = 즉 **고정 길이**<br>

  - 실제 CRC 값: 대부분 32비트 다항식(`기약다항식`)으로 데이터를 나눴을 때의 나머지로 데이터 축약 -> 즉 32비트의 어떤 비트값이 검증값이 됨
  - 예시와 같이 *'13으로 나눈 나머지값'* 같은 함수는 특정 검증값을 도출할 입력값을 찾기가 굉장히 쉽다.
  - 따라서 *'검증값을 만드는 함수를 어떻게 설계할 것인가'* 고민할 필요가 있다.<br>

### 3. 데이터와 검증값
1. 검증값은 충분히 작은 길이로 축약되어야 함
2. 비교적 빠르게 계산되어야 함
3. 검증값으로부터 입력 데이터를 유추하기 어려워야 함
4. 검증값을 가지는 데이터를 만들기 어려워야 함
=> 암호 기술 `해시함수` 등장<br>

# 해시함수란?
## 해시함수의 개념
### 1. 검증값 (validation value) 사용
- 위, 변조 여부 검증 및 무결성 검증 가능하게 하려면? *주어진 `검증값`에 대한 입력값을 쉽게 유도할 수 없게 해야 한다.'*
-> `해시함수(Hash function)` 등장
- 예시) 재판에서 증거의 해시값이 다르다는 이유로 증거가 조작될 가능성이 있다는 판례<br>

### 2. 해시 함수란?
- 임의의 입력을 받아 고정된 길이의 출력값을 내는 함수
- 계산의 용이성 반드시 필요: 임의의 길이를 가지는 입력값이기 때문에 굉장히 큰 값이 들어올 수 있다는 것을 전제로 함수가 동작해야 한다.
- 그러나 결과값이 너무 작으면? 동일한 `검증값`을 내는 `입력값` 너무 쉽게 유추 가능하면 안됨<br>


### 충돌(Collision)
- 다른 입력값에 대해 동일한 출력값을 내는 상황
- 임의 길이의 입력을 받아 *압축, 고정된 길이의 결과값*을 내기 때문에 어쩔 수 없이 충돌 가능성 있음
- 충돌 100% 방지는 불가능하지만, 이 충돌되는 상황을 찾기 굉장히 어렵게 설계함<br>

## 해시함수의 성질
### 1. 충돌 저항성 (Collision Resistance)
- 동일한 출력값을 내 놓는 서로 다른 입력값 찾는 것이 어렵도록 (*계산상 불가능하도록*) 설계된 함수
- *'계산 상 불가능하다?'* 의 의미: 충분히 긴 길이의 해시값을 가져서 현재, 혹은 근미래의 컴퓨터의 계산 능력으로 천문학적인 시간이 걸리는 수준. 현 시대 컴퓨터의 연산 능력에 기준하기 때문에 미래 더 고성능의 기계가 나오면 의미가 변할 수 있음.
- 기계 연산 능력 발전에 따라 해시함수 결과물이 계속 길어지고 있음
  1. `MD5` 해시함수: 128비트 결과값
  2. `SHA1` 해시함수: 2010년 이전 주로 사용, 160비트 결과값
  3. `SHA256` 해시함수: 256비트 결과값 (현재 권장되는 출력값은 224비트)<br>


### 2. 역상 저항성 (Preimage Resistance)
- 역상(Preimage)이란? Pre + image(함수의 결과값): 즉 함수 결과값(image)에 대응하는 입력값이 Preimage이다.
- 역상 저항성이란?
  - 주어진 해시값(결과값)에 대응하는 입력값을 찾기 어렵게 설계된 성질
  - 검증값으로부터 입력값인 x를 찾는 것이 *계산 상 불가능하다*
- 충돌 저항성과 비슷하게 실제 입력값 x를 찾는다고 해도 해당 값의 `데이터 형식`까지 알아내긴 힘들다. (문서, 이미지파일, 동영상 등)<br>


### 3. 제2 역상 저항성 (Seconde Preimage Resistance)
- 해시함수의 입력값이 x, 출력값이 y라고 할 때 같은 출력값 y를 만들어내는 다른 입력값 x'를 찾는 게 계산 상 불가능하다.<br>

- 충돌 저항성, 역상 저항성, 제2 역상 저항성의 성질을 모두 가진 해시함수를 설계하면 충분히 무결성을 담보할 수 있게 된다.<br>


# 블록체인과 해시함수
## 장부의 동기화
### 1. 검증값을 이용한 장부 비교
- `블록체인`은 분산 시스템에서 모든 노드가 동일한 장부를 유지, 관리한다.
- 그러면 내가 가진 장부와 다른 사람이 가진 장부가 동일하다는 것을 어떻게 증명할 수 있나? -> `해시함수`사용<br>

1. 내가 가진 장부가 위, 변조(tampered)되었는지 확인하는 방법
  - 개인이 가진 장부 = 장부 + 기존 장부에 해당하는 검증값(해시값) 형태
  - 내 장부 내용을 해시함수에 넣은 결과값과 `검증값` 비교<br>

2. 다른 사람의 장부와 내 장부를 비교할 때
  - 각 장부의 해시값을 주고 받아 비교
  - 해시함수의 성질: 동일한 해시값을 출력하는 다른 입력값(변조된 내용) 찾기 매우 힘듦(`제2 역상 저항성`)<br>


### 2. 전체 장부 비교가 아닌 일부 거래 비교
- 모든 사용자는 시스템 전체 거래 기록을 가지고 있다.
- 내 거래가 전체 거래 기록에 포함되어 있는지 확인하고 싶을 땐? 전체 기록 다 가져오는 것은 비효율적
- 전체의 일부분이 무결한지 확인: **머클트리(Merkle Tree)** 사용
- 머클 트리란? 전체 블록체인 거래 내역의 요약본. 이진 트리(binary Tree)이기도 하다.
![머클트리](https://user-images.githubusercontent.com/54266900/66581327-e3373000-ebba-11e9-9ca8-74fbbdb9e543.PNG)
- 내 거래 내역 `C`를 찾는 방법
  1. 내 거래 내역 C를 해시한 값 `HASH(C)=33`이라고 가정한다.
  2. HASH(C)와 연접한 HASH(D)값을 해시해서 HASH (C, D)값 생성
  3. 인접한 HASH(A, B)와 HASH(C, D)를 다시 해쉬함수에 넣어서 루트 해시값 생성
  4. 나중에 C를 찾으려면 루트 해시값을 2번 해시하면 해당 값 찾을 수 있다.<br>

- `머클트리`의 이점: 이렇게 두 개씩 묶어서 올라가게 되면 거래량이 기하급수적으로 늘어나도 특정 거래를 찾는 경로는 단순해진다.
  - 거래 두 개씩 묶음 -> 해시 함수(`SHA256 알고리즘`, 32비트 출력) -> 새로운 해시값 생성 -> 루트 해시값 하나로 요약될 때까지 반복
  - 거래 수와 상관 없이 요약된 머클 루트의 용량은 32바이트로 항상 같다.
  - 거래 건수 N -> 특정 거래 경로 찾는 경우의 수 log2(N)
  - 블록체인 거래량 늘어나기 때문에 전체 장부 용량은 계속 늘어남. 모든 기기에서 데이터를 다 저장하기 힘든데 머클트리를 통해 필요한 정보만 받을 수 있어 쉽고 빠르게 특정 거래 검색 가능

- 머클트리 추가 조사 링크: https://banksalad.com/contents/%EC%89%BD%EA%B2%8C-%EC%84%A4%EB%AA%85%ED%95%98%EB%8A%94-%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC-Merkle-Trees-%EB%9E%80-ilULl
<br>

## 장부의 위변조
### 1. 블록체인의 구조
- 블록체인이란?
  - 10분 간의 거래 내용이 담긴 블록을 체인으로 연결한 것
  - 블록은 순차적으로 생성, 연결된다.

![블록체인해시값](https://user-images.githubusercontent.com/54266900/66582415-b7b54500-ebbc-11e9-8235-a43cd0aec0df.PNG)
- 블록체인에서 블록들 간 순서를 표시하는 방법: `해시값` 이용
  1. 블록 1 생성: 블록 1 전체 거래내용에 대응하는 `블록1 해시값` 생성됨
  2. 블록 2 생성: `블록1 해시값` 저장, 다시 블록 2 내용에 대응하는 `블록2 해시값`생성
  3. 블록 3 생성: `블록2 해시값` 저장, 다시 블록 3 내용에 대응하는 `블록2 해시값`생성<br>

![블록체인위변조](https://user-images.githubusercontent.com/54266900/66582726-3316f680-ebbd-11e9-8b30-91033f0c70e8.PNG)
- 만약 블록 하나를 위, 변조를 한다면?
  1. 블록2 내용 위조됨: `블록1 해시값`은 변함 없음, 블록2의 내용(입력값)이 바뀌었으므로 `블록2 해시값`이 변경됨
  2. `블록2 해시값`을 가지는 블록3 내용 변경됨: `블록2 해시값`을 포함하고 있다가 변경되었으므로 그에 대응하는 `블록3 해시값`도 변경됨
  3. 마지막 블록까지 전부 내용과 그에 해당하는 해시값 변경하면 위조 가능<br>

### 2. 블록의 변조를 어렵게 만드는 방법
- 해시함수 특징: 해시값의 계산이 매우 용이하다. 즉 입력값 많아도 계산속도 굉장히 빠름. 블록 수 천개의 해시값을 계산하는 것도 매우 빠름.
- 변조 방지 방법
  1. 원본 장부를 많은 사람에게 공유: 블록의 거래 내용을 변조시키려면 시스템 전체 사용자의 장부 절반 이상을 바꾸어야 하는 결과
  2. 해시값을 아무나 만들 수 없도록 한다: 해시값을 만들 수 있는 사람, 디바이스를 구별하기 위한 *비밀정보* 만듦 -> 그럼 다시 해당 키(비밀정보)를 시스템 일부 사용자들(해시값 생성 가능한 노드들)이 공유해야 하는 문제 생김
  3. 블록 하나 생성 시 시간이 많이 걸리도록 함
    - 해시함수 계산은 굉장이 빠르게 가능
    - 하지만 계산한 값으로 변조된 블록을 생성하는 데 일정 시간 이상 시간이 소요되면? 변조된 블록 빠르게 만들 수 없다. =>`채굴(Mining)`<br>

### 3. 블록의 생성: 채굴(Mining)
- 블록을 생성 할 때 일정 시간이 걸리도록 설계: 블록에 대한 적당한 해시값을 만드는 데에 `난이도`를 적용함
- 블록에 `넌스(nonce)`값 포함
- *넌스(nonce)값이란?* 블록의 해시값을 만들기 위해 해시함수에 집어넣는 입력값(기존: 거래내용)에 추가로 붙여지는 값으로 사용자가 임의로 값을 변경할 수 있는 부분.
- 블록에 대한 해시값을 만들 때 일정 시간이 걸리도록 *'조건'*을 준다.
  - 예시) *"최상위 비트가 00인 해시값을 찾아서 반환해라"*
  - 그러면 00, 01, 10, 11 4가지 경우의 수가 생긴다. -> `넌스(nonce)값`을 바꾸가면서 평균 4번 해시함수를 수행하면 조건에 맞는 해시값 반환 가능
  - 조건의 경우의 수가 많아질수록 계산에 오랜 시간이 걸린다. (비트코인은 평균 10분)
- 따라서 일정 시간을 들여 조건에 맞는 해시값을 찾아내는 과정 = `작업 증명(proof of work)`, `채굴`<br>


![알기쉬운블록체인_마인드맵_6주차](https://user-images.githubusercontent.com/54266900/66585212-68254800-ebc1-11e9-9300-2d7077d8b39b.jpg)


