---
title: "[블록체인] 11주차_블록의 생성 2"
categories:
  - BlockChain
tags:
  - BlockChain
  - 블록체인
  - K-MOOC

comments : true
---
*이 내용은 K-MOOC [알기쉬운블록체인] 강의를 듣고 정리한 내용입니다.*
<br>

[알기쉬운블록체인]: http://www.kmooc.kr/courses/course-v1:SJCU+SJCU01+2019_2/courseware/145ba5714d1246c1b65fe1b081d52db0/e1af1659e74343579fe5727acdfcfbc7/?child=last

<br>

# 블록 생성 시 발생하는 문제들
## Node의 작업 상태
### 1. Node들의 두 가지 작업 상태
1. 작업 상태 종류
    1. peer가 생성하고 제출한 새 블록 평가하는 상태
    2. 새 블록 만드는 상태
        - hash puzzle 플어서 블록 완성하고 제출
        - 다른 peer들의 검증 결과를 기다려야 한다.
2. 작업 상태 결정하는 요인: 개별 node에 도착하는 message
    - 각 노드는 새 블록을 포함하는 메시지를 받자마자 평가 상태로 전환
    - 평가가 완료되면 새 블록 생성 상태로 전환<br>

## Node의 처리 규칙
### 1. 노드의 처리 규칙
1. 새 트랜잭션 데이터와 새 블록은 peer간 네트워크 통신으로 전달
2. 각 노드는 message수신함에 모인 새 트랜잭션 중 선택해서 처리
3. 각 노드는 새 블록을 최우선으로 처리한다.: 트랜잭션 처리 vs 새로운 블록 검증-> 블록 처리 우선
4. 각 노드는 새 트랜잭션 데이터의 승인 여부와 형식상, 의미상 정확성 검증하여 처리
5. 각 노드는 유효한 트랜잭션들만 골라서 Merkle tree를 구성하고, hash puzzle 풀어 새 블록 생성
6. 각 노드는 hash puzzle을 해결하자마다 새로 생성한 블록을 모든 노드에게 전달
7. 각 노드는 새 블록에 대해 hash puzzle의 해를 검증하고, 새 블록에 포함된 모든 트랜잭션 데이터의 형식, 의미상 정확성 및 승인 여부 검증: hash puzzle의 해를 찾는 것은 어렵지만, 해를 검증하는 것은 쉽다.
8. 각 노드는 자신이 가진 `블록체인-데이터-구조`의 복사본에 유효한 블록을 추가
9. 새 블록이 유효하지 않을 경우 이를 폐기하고, 노드는 계속 트랜잭션 데이터를 처리하거나 새 블록의 hash puzzle을 처리하는 등 하던 일 이어서 처리
10. 새 블록이 유효한 경우 노드는 새 블록에 포함된 트랜잭션들을 message수신함에서 제거하고, 트랜잭션 데이터 처리 및 새 블록 생성 시작
11. `블록체인-데이터-구조`에 추가된 블록이 추후 유효하지 않거나 불필요한 것으로 밝혀지면, 그 블록과 이후에 연결된 모든 블록을 제거한 다음, 해당 트랜잭션들은 재처리를 위해 message수신함에 다시 추가된다.
12. 제출한 블록의 유효성을 인정 받은 노드는 블록에 포함된 모든 트랜잭션에 대해 보상 받는다.
13. 새로 추가되었던 블록이 추후 검증을 통해 제거되면 이를 제출한 노드는 받았던 보상금 반환<br>

## 부정직한 Node의 처리
### 1. 시스템의 목표
- 안정성, 신뢰성 알 수 없는 개별 노드들로 구성된 완전 개방 P2P시스템에서 **무결성**과 **신뢰성**을 유지하는 것

### 2. 소유권 관리하는 P2P시스템에서 가장 두드러진 부정행위
1. 다른 사람으로 위장해 transaction 제출
2. 유효하지 않은 transaction이나 블록 인정: 여러 노드 담합->한 노드가 조작한 데이터 블록을 다른 노드들이 인정해줌
3. 노드를 다운시키기 위해 수많은 transaction data 전송: 한꺼번에 많은 트랜잭션 발생시켜 `Denial of Service`공격 효과: 전체 블록체인 시스템이 정상적인 트랜잭션도 제대로 처리하지 못하는 상태가 될 수 있음
4. 특정 transaction의 처리 거부: 특정 주소값을 가진 사람의 transaction 계속 거부하면 그 사람은 거래 불가
5. 정보 전달 거부: 내가 받은 정보를 피어들에게 전달하지 않음<br>

### 3. 부정직한 행위의 방지책
1. 각 게정의 `개인key`를 소유한 주인에게만 접근을 허용하는 transaction의 보안 개념 적용
    - 계정 주인 및 거래 식별, 인증: `비대칭 암호화 기법`, `디지털 서명`
    - 따라서 다른 사람으로 위장해서 transaction 제출하는 것 자체가 불가능
2. peer들 간 통신으로 모든 노드가 모든 정보 수신하는 것 보장
    - 일부 노드가 정보 전달 거부해도 다른 경로로 정보 전달 ->결국 모든 노드가 모든 정보 알게 됨
3. 특정 노드가 잘못되거나 데이터 처리를 멈추어도 전체 시스템은 작동하는 시스템 구조
    - 일부 노드 과부하&다운 혹은 일부 노드가 거래 처리 거부해도 다른 노드들이 그 역할 대신 해 줄 수 있음
4. 블록체인-알고리즘
    - 일부 부정직한 노드들이 조작 시도해도 합의 알고리즘에 의해 정직한 다수의 힘으로 극복
    - 적절한 보상과 처벌의 효과
        - 무결성을 해치려는 부정직한 노드의 욕망: 위조된 transaction 보냄 or 유효하지 않은 transaction이나 블록 승인
        - 보상을 향한 다수의 열망: 훨씬 크고 강력함
    - 이를 위해 기본적으로 **꽤 많은 숫자의 정직한 노드**를 확보하는 것이 필요<br>



