---
title: "[블록체인] 11주차_블록의 생성 2"
categories:
  - BlockChain
tags:
  - BlockChain
  - 블록체인
  - K-MOOC

comments : true
---
*이 내용은 K-MOOC [알기쉬운블록체인] 강의를 듣고 정리한 내용입니다.*
<br>

[알기쉬운블록체인]: http://www.kmooc.kr/courses/course-v1:SJCU+SJCU01+2019_2/courseware/145ba5714d1246c1b65fe1b081d52db0/e1af1659e74343579fe5727acdfcfbc7/?child=last

<br>

# 블록 생성 시 발생하는 문제들
## Node의 작업 상태
### 1. Node들의 두 가지 작업 상태
1. 작업 상태 종류
    1. peer가 생성하고 제출한 새 블록 평가하는 상태
    2. 새 블록 만드는 상태
        - hash puzzle 플어서 블록 완성하고 제출
        - 다른 peer들의 검증 결과를 기다려야 한다.
2. 작업 상태 결정하는 요인: 개별 node에 도착하는 message
    - 각 노드는 새 블록을 포함하는 메시지를 받자마자 평가 상태로 전환
    - 평가가 완료되면 새 블록 생성 상태로 전환<br>

## Node의 처리 규칙
### 1. 노드의 처리 규칙
1. 새 트랜잭션 데이터와 새 블록은 peer간 네트워크 통신으로 전달
2. 각 노드는 message수신함에 모인 새 트랜잭션 중 선택해서 처리
3. 각 노드는 새 블록을 최우선으로 처리한다.: 트랜잭션 처리 vs 새로운 블록 검증-> 블록 처리 우선
4. 각 노드는 새 트랜잭션 데이터의 승인 여부와 형식상, 의미상 정확성 검증하여 처리
5. 각 노드는 유효한 트랜잭션들만 골라서 Merkle tree를 구성하고, hash puzzle 풀어 새 블록 생성
6. 각 노드는 hash puzzle을 해결하자마다 새로 생성한 블록을 모든 노드에게 전달
7. 각 노드는 새 블록에 대해 hash puzzle의 해를 검증하고, 새 블록에 포함된 모든 트랜잭션 데이터의 형식, 의미상 정확성 및 승인 여부 검증: hash puzzle의 해를 찾는 것은 어렵지만, 해를 검증하는 것은 쉽다.
8. 각 노드는 자신이 가진 `블록체인-데이터-구조`의 복사본에 유효한 블록을 추가
9. 새 블록이 유효하지 않을 경우 이를 폐기하고, 노드는 계속 트랜잭션 데이터를 처리하거나 새 블록의 hash puzzle을 처리하는 등 하던 일 이어서 처리
10. 새 블록이 유효한 경우 노드는 새 블록에 포함된 트랜잭션들을 message수신함에서 제거하고, 트랜잭션 데이터 처리 및 새 블록 생성 시작
11. `블록체인-데이터-구조`에 추가된 블록이 추후 유효하지 않거나 불필요한 것으로 밝혀지면, 그 블록과 이후에 연결된 모든 블록을 제거한 다음, 해당 트랜잭션들은 재처리를 위해 message수신함에 다시 추가된다.
12. 제출한 블록의 유효성을 인정 받은 노드는 블록에 포함된 모든 트랜잭션에 대해 보상 받는다.
13. 새로 추가되었던 블록이 추후 검증을 통해 제거되면 이를 제출한 노드는 받았던 보상금 반환<br>

## 부정직한 Node의 처리
### 1. 시스템의 목표
- 안정성, 신뢰성 알 수 없는 개별 노드들로 구성된 완전 개방 P2P시스템에서 **무결성**과 **신뢰성**을 유지하는 것

### 2. 소유권 관리하는 P2P시스템에서 가장 두드러진 부정행위
1. 다른 사람으로 위장해 transaction 제출
2. 유효하지 않은 transaction이나 블록 인정: 여러 노드 담합->한 노드가 조작한 데이터 블록을 다른 노드들이 인정해줌
3. 노드를 다운시키기 위해 수많은 transaction data 전송: 한꺼번에 많은 트랜잭션 발생시켜 `Denial of Service`공격 효과: 전체 블록체인 시스템이 정상적인 트랜잭션도 제대로 처리하지 못하는 상태가 될 수 있음
4. 특정 transaction의 처리 거부: 특정 주소값을 가진 사람의 transaction 계속 거부하면 그 사람은 거래 불가
5. 정보 전달 거부: 내가 받은 정보를 피어들에게 전달하지 않음<br>

### 3. 부정직한 행위의 방지책
1. 각 게정의 `개인key`를 소유한 주인에게만 접근을 허용하는 transaction의 보안 개념 적용
    - 계정 주인 및 거래 식별, 인증: `비대칭 암호화 기법`, `디지털 서명`
    - 따라서 다른 사람으로 위장해서 transaction 제출하는 것 자체가 불가능
2. peer들 간 통신으로 모든 노드가 모든 정보 수신하는 것 보장
    - 일부 노드가 정보 전달 거부해도 다른 경로로 정보 전달 ->결국 모든 노드가 모든 정보 알게 됨
3. 특정 노드가 잘못되거나 데이터 처리를 멈추어도 전체 시스템은 작동하는 시스템 구조
    - 일부 노드 과부하&다운 혹은 일부 노드가 거래 처리 거부해도 다른 노드들이 그 역할 대신 해 줄 수 있음
4. 블록체인-알고리즘
    - 일부 부정직한 노드들이 조작 시도해도 합의 알고리즘에 의해 정직한 다수의 힘으로 극복
    - 적절한 보상과 처벌의 효과
        - 무결성을 해치려는 부정직한 노드의 욕망: 위조된 transaction 보냄 or 유효하지 않은 transaction이나 블록 승인
        - 보상을 향한 다수의 열망: 훨씬 크고 강력함
    - 이를 위해 기본적으로 **꽤 많은 숫자의 정직한 노드**를 확보하는 것이 필요<br>


# 분쟁의 해결
## 동일한 거래 이력의 유지
### 1. 블록체인 내 모든 노드들이 같은 정보 유지하는 방법?
- 예시) 새로운 길의 생성: 수많은 경로 중 많은 사람들이 사용해서 다져 진 길이 선택됨 = 합의의 결과
- 블록체인에서 모든 노드들이 같은 정보를 유지하게 만드는 원리 = 합의 메커니즘<br>

### 2. 해결 과제
- 블록체인-알고리즘에는 중앙 통제 장치가 없고, 각 노드가 수신함에 도착한 메시지를 보고 어떤 일을 할 지 판단함
- 즉 개별노드의 수신함에 도착한 새 블록이 노드가 뭘 해야 할 지 알려주는 신호이다.
- 문제점
    1. message가 분실, 지연, 또는 순서 바뀔 수 있음
    2. 모든 노드의 작업 상태가 동일하지 않음
    3. node들의 작업이 중복될 수 있음
- 그럼에도 불구하고 모든 노드가 동일한 거래 이력 유지하도록 만드는 것이 과제<br>


## 해결 방법
### 1. 분산 합의
- 분산합의란? 집단적 의사결정 문제에서 동의나 합의에 이르는 과정
- 중앙 통제, 조정 없이 독립적으로 행동하는 개인들에 의한 합의<br>

### 2. 분산 합의 과정의 특징
1. 집단을 구성하는 독립된 개인들은 동일한 환경에서 행동함
    - 주어진 Peer to Peer 네트워크가 동일
    - 네트워크를 통해 전달되는 정보가 동일
    - 동일한 규칙에 의해 동작됨
2. 집단적 의사결정이 필요한 문제가 존재함
    - 새 블록 생성 시 해당 블록 검증하기
    - 여러 블록이 충돌 일으킬 때 어느 쪽을 선택할지
3. 개인들은 동일한 목표 달성을 위해 독립적으로 노력함
    - 각 노드의 목표: 새로운 블록을 자기가 만들어서 등록->보상 받기
4. 목표달성을 위해 개인이 취한 행동은 환경에 영향을 미쳐서 집단적인 의사결정 문제를 결정하는 데 도움됨
    - 새 블록 생성 or 타인의 블록 검증 등이 전체 의사결정 과정의 일부
5. 각 개인은 환경 변화에 기반한 동일한 기준을 사용해서 의사결정 문제 평가<br>

### 3. BlockChain의 분산합의
1. 모든 노드는 네트워크 `블록체인-데이터-구조`에 개별 복사본을 가지고 동일한 알고리즘에 의해 동일한 환경에서 작동함
2. 집단 의사결정 문제: 단일 transaction 선택 문제
3. 모든 노드는 자신의 이익을 최대화하기 위해 유효한 새 블록 추가하고 보상 받기 위해 노력함
4. 각 노드는 자신이 생성한 새 블록을 다른 피어들에게 인정받기 위해 공개함: 각 노드는 집단으로 유지되는 블록체인-데이터-구조 환경에서 개별적인 흔적 남김
5. 작업 증명(POW)방식의 경우 새 블록 생성에 많은 노력이 들고 이를 조작하는 데 더 많은 노력 소요
    - 두 개 이상의 상충되는 트랜잭션 이력이 있으면?
    - 이력 전체에 대해 그 이력을 만드는 데 들어간 총 노력의 양이 큰 쪽 선택: 노력 총량이 클 수록 이력 조작하기 어렵기 때문
    - 모든 노드가 트랜잭션 데이터 선택할 때 동일한 기준을 적용하면-> 모든 녿가 동일한 버전 이력 가지게 됨
    - *autoritative chain(권위 체인)* or *authoritative history*<br>


## 작동 원리 - 가장 긴 체인 기준
### 1. 계산 노력 판단 기준 2가지
1. 가장 긴 chain 기준
2. 가장 무거운 chain 기준<br>

### 2. 가장 긴 chain 기준
- 전제: 많은 블록을 가진 트랜잭션 이력을 만드는 데 가장 많은 계산 노력이 들어갔을 거라고 가정
- 네트워크 상 속도 차이로 인해 두 개 이상의 블록이 거의 동시에 새로 생성이 된다면?
- 길이가 같은 두 개 이상의 블록이 있으면 개별 노드가 임의로 선택함(=새로운 블록 생성해서 선택한 블록 뒤에 붙임)
- 길이가 다른 블록이 생기면 사람들이 더 긴 블록에 새 블록 붙이려 함-> 짧은 블록 자연스럽게 도태됨
- 도태되어 쓰이지 않는 블록을 만든 사람들은 추후 블록 생성 보상 반환 (필요 없거나 유효하지 않은 블록임이 밝혀지면 보상 회수)

## 작동 원리 - 가장 무거운 체인 기준
### 1. 가장 무거운 체인 기준
- 과연 *'길이가 가장 긴 체인'*이 가장 많은 노력을 소요한 체인
- 각 블록 생성 시 해시 퍼즐 난이도가 동적으로 결정됨 -> 즉 각 블록 만들어질 때 들어가는 노력 다름
- 블록 별로 난이도가 표시되어 있으니 체인 갈래가 나뉘었을 때 난이도의 합을 비교한다.
![11_2_3_가장무거운체인](https://user-images.githubusercontent.com/54266900/68071162-0bc9d880-fdbb-11e9-82c1-5e274cbb6a74.PNG)


### 2. 선택 받지 못한 chain의 처리
- 고아 블록: 권위 블록이 아닌, 선택 받지 못한 블록
- 권위 chain이 선택되면, 나머지 가지에 속한 블록은 버려짐
- 권위 chain에 속해있지 않음 = 고아 블록 = 소유권 명확하게 하는 데에 도움 안 됨 = 보상 회수
- 고아 블록 및 그 후속 블록을 생성해서 받은 보상 회수됨
- 고아 블록에 포함된 transaction들은 발생한 적이 없던 것으로 간주
- 고아 블록에 포함되어 버려 진 transaction 수신함으로 수거됨-> 차후 다시 추가될 기회 얻게 됨<br>

### 3. 블록 처리 과정
1. 공통 몸통의 성장: 충돌되는 블록체인이 공통으로 연결되어 있는 부분들은 권위 체인의 일부임이 명확해짐
2. 궁극적인 일관성 생김: 권위 체인에 속해 있어도 가장 나중에 붙은 블록은 다른 노드의 선택에 의해 언제든 고아 블록이 될 수 있지만, 오래 전에 만들어져 권위 체인의 안쪽에 있는 블록들은 고아 블록이 될 위험성이 없다.
3. 조작에 대한 견고성 구축: 권위 체인의 일부 블록을 조작하기 위해서는 그 후로 붙어 있는 모든 불록을 다시 새로 만들어야 함 ~ 이미 만들어진 체인보다 더 빨리, 더 길게, 더 무겁게(어렵게) 만들어서 권위 체인으로 선택받는 것이 아주 어려움<br>

## 조작의 방지
### 1. 공격자의 목표
- 권위 chain의 일부를 고아 블록으로 만듦
- 조작된 transaction들로 이루어진 새로운 블록들을 권위 chain에 포함시킴
- 공격자에게 이익을 가져다 주도록 소유권 정보를 배부<br>

### 2. 조작의 다양한 관점
- 경제적 측면: transaction 이력을 변경하여 소유권 조작
- 정치적 측면: 집단적 의사결정과 관련해 원하는 결과를 얻기 위해 대다수의 표를 얻는 것
- 기술적 측면: 시스템 무결성 약화<br>

### 3. 조작 방법
- 숨겨진 중앙 통제 요소를 일정 시간 이상 확보-> 시스템 상태 변경
- 예시) **51% 공격**: 의사결정을 위한 권리, 힘을 얻기 위해 전체 네트워크의 51%이상 확보해야 함<br>

### 4. hash puzzle을 이용한 조작 방지
- 블록 생성 시 계산 비용 높아짐 -> 조작 방지
- 기술적 관점: 불변성을 부여하기 위한 수단으로 해시 퍼즐 사용 됨
- 예시) 각각의 블록이 선거라고 하면
    1. 어떤 노드가 새로운 블록 생성, 배포(publish)하는 것 = 선거 출마
    2. 생성된 블록을 기존 블록체인 구조에 붙일 것인지 선택 = 투표
    3. hash puzzle은 선거 출마(새 블록 생성)에 드는 비용 증가시킴
    4. 아무나 출마(조작된 새 블록 생성)하는 것 억제: 부정직한 사람들이 투표에 참여하는 것 억제<br>



