---
title: "[블록체인] 8주차_블록체인과 암호기술 2"
categories:
  - BlockChain
tags: BlockChain, 블록체인, 해시함수
comments : true
---
*이 내용은 K-MOOC [알기쉬운블록체인] 강의를 듣고 정리한 내용입니다.*
<br>

[알기쉬운블록체인]: http://www.kmooc.kr/courses/course-v1:SJCU+SJCU01+2019_2/courseware/145ba5714d1246c1b65fe1b081d52db0/e1af1659e74343579fe5727acdfcfbc7/?child=last

<br>

# 거래 데이터의 신뢰성
## 전자서명의 필요성
### 1. 블록체인에 전자서명(electric signature)가 필요한 이유
- 분산 시스템의 서로 다른 장부가 같은지 확인하기 위해 `해시값` 비교
- 그런데 `해시 함수` 만으로 전체 시스템 `무결성` 확보 가능할까?
- 변경된 내용에 대한 새로운 해시값 생성해서 전송 -> 새로운 해시값도 형식은 유효하기 때문에 해당 값 자체만 보고 위, 변조 여부 확인하기는 어렵다.
- 검증값으로 확인하려면? `제 3의 신뢰할 수 있는 자(trusted third party)`가 공개한 검증값과 내가 받은 검증값을 비교하면 된다.
- 공개 검증값 없는 경우는?<br>

### 2. 공개된 네트워크에서 주고 받는 데이터를 어떻게 신뢰할 수 있을까?
1. *이 메시지는 정당한(legimate) 송신자가 보낸 것이 맞는가?*
    - "A가 보냈다는 데이터를 받았는데 이게 진짜 A가 보낸 것이 맞는가?"
    - 예시) 편지 봉투 겉면에 '보내는 사람'만 보고 송신자가 바뀌지 않았음을 알수 있나? (쉽게 다른 사람 이름으로 변조 가능)
2. *송신자가 보낸 메시지가 맞는가?*
    - "A가 보낸 메시지는 맞는데 내용도 원본과 일치하는가?"
    - 예시) 편지 내용만 보고 이 사람이 보낸 내용이 맞다고 확신할 수 있나? (내용만 보고는 편지 내용이 변경되지 않았는지 알기 힘들다)<br>

### 3. 편지의 위, 변조를 막기 위해 사용한 방법
- 중세시대 밀랍과 인장: 편지 내용을 보호하고 아무나 열지 못하도록, 또는 개봉되었음을 쉽게 식별하기 위해 편지 봉인해서 보냄
- 편지에 `서명(signature)`: 위조가 어렵게 하고, 내가 해당 문서에 동의 혹은 해당 문서를 내가 만들었다는 것을 표현함
- 수결 (손바닥 모양대로 본 뜨기): 글을 쓰지 못하는 경우
- 고유 도장 사용
- 온라인에서도 이와 유사하게 서명과 같은 행위 필요해짐<br>

### 4. 전자서명의 필요성
- 인터넷: `비대면`으로 데이터 주고 받음
- 온라인 비대면 거래가 증가하며 상대방 확인할 새로운 방법 필요
- 디지털 데이터의 특성 상 쉽게 위, 변조가 가능함
- 일상생활에서 계약서에 서명하는 것과 같은 상황을 온라인에서 구현해야 함
- 결과) `전자서명` 도입<br>


## 전자서명의 특징
### 1. 전자서명(Digital Signature)이란?
- 디지털 데이터에 서명하는 방법
- 서명된 메시지가 디지터 데이터로 표현됨 -> 당연히 컴퓨터 네트워크를 통해 송신, 수신 가능
- 필요 기능
    1. 신뢰성 제공: 이 디지털 데이터(전자서명)을 생성한 사람이 누구인지 `인증(Authentication)`
    2. 무결성 기능: 디지털 데이터가 원본과 다름없이 변조되지 않았음을 식별할 수 있어야 한다.<br>

### 2. 기존 서명 VS 전자 서명
- 기존 서명
    - 물리적으로 서명된 문서의 일부임 (문서 / 서명 분리 불가)
    - 원본 서명과 인쇄한 복제본이 확연히 식별 가능
    - 사용 방식) 신용카드로 물건 구매하는 경우: 신용카드 뒤 서명(원본)과 수기로 쓴 서명을 대조해서 해당 서명이 정당한지 판단
- 전사 서명
    - 디지털 데이터 값으로 존재 -> 문서 내용과 서명값이 별도 값으로 존재
    - 따라서 원본 데이터와 데이터에 대한 서명값 묶는 역할 필요
    - 비교할 데이터와 서명값이 주어진 상황에서 누구나 손쉽게 서명 진의 여부 확인해야 함
    - 사용 방식) 공개적으로 알려진 정보를 사용하여 메시지에 대응하는 서명값을 누구나 확인, 검증할 수 있다.
    - 데이터 복제가 쉽다 -> 원본과 사본이 동일 ->재사용 방지 대책 필요
    - 재사용 방지: 거래 당시의 날짜 정보, 혹은 거래 번호 등 서명을 생성할 때마다 동일한 서명값이 나오지 않도록 만들 수 있는 체계 필요<br>


### 3. 전자 서명의 요구조건
1. 위조 불가 (Unforgeable): 정당한 서명자(legimate signer)만이 전자서명 생성 가능
    - 다른 사람의 서명 쉽게 만들 수 없도록 한다
    - 기존 서명) 필적대조, 인감도장 사용 등 위조 방지를 위한 노력
    - 디지털 데이터 변조 시 사람보다 훨씬 빠른 계산능력을 가진 컴퓨터가 수행하니 매우 어려워야 함<br>

2. 서명자 인증 (Authentic): 누구든지 서명자 확인 가능
    - 기존 서명) 우리가 직접 적은 서명과 대조본 비교해서 서명 진위여부 판단
    - 온라인 상 데이터: 누구나 데이터를 보고 이것이 정당한 서명자가 인증한 것임을 확인할 수 있어야 한다.
    - 또한 확인 과정은 비교적 빠른 시간 내 이루어져야 한다.<br>

3. 재사용 불가 (Not Reusable): 다른 문서의 서명으로 사용 불가
    - 어떤 문서에 서명을 할 시 그 문서에 대한 `서명값` 생성됨
    - 다른 사람이 다른 문서의 서명으로 주어진 서명값을 사용하는 게 불가능하도록 해야 한다.<br>

4. **변경 불가 (Unalterable): 서명된 문서의 내용 변경 불가**
    - 기존 서명) 내용과 서명이 물리적으로 분리 불가능 -> 문서 위조를 위해 서명도 위조해야 한다.
    - 디지털 데이터 특성 상 데이터(내용)과 데이터에 대한 서명값은 별도 값으로 존재
    - 따라서 다른 데이터에 대한 같은 서명값이 나오거나, 다른 서명값이 원래 문서에 대응한다는 증명이 불가능하도록 설계해야 한다.<br>

5. 부인 방지 (Nonrepudiation): 서명 사실 부인 불가
    - 기존 서명) 수표 발행 시 *'이서'*하고 발행 -> 수표 발행 후 발행 사실 부인해도 이서한 것과 내 서명이 같으면 내가 발행한 사실을 부인할 수 없다.
    > 이서하다: 법률> 「…에」 [같은 말] 배서하다(2. 민법에서, 채권 양도(債權讓渡)의 의사 표시를 증권의 뒷면에 기재하다). 예시: 수표에 이서해 주십시오.
    - 전자 서명) 나와 내가 한 서명이 `매핑`되어야 함
    - 데이터에 대한 서명값 생성 시 **'키(key)'** 필요
    - 이 key의 소유자가 나라는 것을 다시 매핑하는 연결고리 필요
    - 예시) 공인인증서 발급 시 여러 가지 채널로 '나'임을 증명 (ARS, 아이핀, 문자 인증 등등)
    - 인증서 등 전자서명: '나'에 대한 정보 + 공개 키 정보값 + 그걸 검증해 준 사람의 서명 ~ `신뢰할 수 있는 제 3자`가 보장해주는 기능 포함<br>


# 전자서명이란?
## 전자서명의 개념
### 1. 전자서명의 요구사항
1. 정당한 서명자만이 생성할 수 있어야 한다.
    - '서명 생성' 권한을 가진 사람을 식별해야 함 = `인증` 필요
    - 예시) 패스워드 인증: 남에게 공개되지 않고 나만 알고 있는 정보를 통해 인증
    - 예시) 해시함수: 공유 키
        - 메시지 변조해서 변조된 메시지에 대한 해시값 계산해서 검증값으로 붙여서 보내면 변조 여부 식별 어려움
        - 따라서 통신 참여자들 간 `비밀 키` 공유: 키 아는 사람만 검증 가능
        - 하지만 전자서명: 누구나 서명 검증할 수 있어야 함<br>

2. 누구든 서명을 확인할 수 있어야 한다.
    - 서명 생성 시: 서명 소유자만 알고 있는 `개인 키(private key)` 사용
    - 서명 검증 시: 누구나 알 수 있는 `공개 키(public key)` 사용
    - 개인 키를 알면 누구나 서명 생성 가능 -> 따라서 개인 키 잘 관리해야 한다.
    - 서명 스킴(signature scheme)
3. 위, 변조를 방지해야 한다.<br>


### 2. 서명 스킴(Signature Scheme): 서명의 구성요소 (P, A, K, S, V)
- P : a finite set of possible Messages (가능한 메시지들의 유한한 집합) = 서명을 붙이려는 원본 데이터 집합
- A : a finite set of possible Signature (가능한 서명들의 유한한 집합) = 메시지 P를 가지고 서명하면 나오는 결과물, 즉 `서명값`의 집합
- K : a finite set of possible Keys (가능한 키들의 유한한 집합) = 개인 키-공개 키 쌍의 전체 집합
- S : 선택한 키로 생성된 서명의 집합 
    - 키 k로 생성한 서명 = `sig_k`: 가능한 메시지 집합과 그에 대응하는 서명 집합 매핑
- V : 생성된 서명을 검증하는 기법
    - 키 k로 생성된 서명 검증 기법 = `ver(verification)_k`
    - 서명 검증 시: 선택한 메시지 + 대응하는 검증 방법 주어짐 -> 검증함수 -> 검증 성공 혹은 실패
    - 즉 서명 검증 = 서명 생성에서 만든 맵이 유효한지 검증<br>

### 3. 전자서명의 구성
1. 키 생성
    - 개인 키 & 공개 키 획득
    - 개인 키 중복 방지 및 보안을 위해 긴 길이 & 랜덤 선택
    - 공개 키: 개인 키에 의해 계산된 어떤 결과값 -> 개인 키-공개 키 쌍으로 존재<br>

2. 서명 생성
    - 서명할 문서: 메시지(사인할 대상)
    - 서명 알고리즘에 입력값 넣으면 출력값 반환
    - 입력: 메시지 + 개인 키
    - 출력: 서명값<br>

3. 서명 검증
    - 누구나 서명을 검증할 수 있어야 함: 공개 키 사용
    - 입력: 메시지 + 서명값 + 공개 키
    - 출력: 검증 성공 혹은 검증 실패<br>


## 전자서명의 예
- 정수 연산으로 구성된 서명 알고리즘
- 전자서명 구성: 키 생성 -> 서명 생성 -> 서명 검증<br>

### 1. 전자서명 예: RSA 공개 키 암호
1. RSA로 키 생성
    - RSA: 소수 p, q를 곱한 값을 n이라고 할 때, n값을 인수분해해도 p, q를 알아내기 어렵다는 사실에 기반하고 있다.
    - 현재~근미래에 컴퓨터로 계산해도 답을 알기 어려운 수준의 인수분해 문제 (값들의 길이가 길다): 현재 2048비트
    - 공개 키 = n, e / 개인 키 = p, q, d<br>
    - RSA 키 생성과정
        1. 랜덤하게 소수 p, q 선택: 각각 약 1000비트
        2. 선택한 소수 p, q 곱해서 n 값 계산
        3. e는 파이n보다 작은 값으로 랜덤하게 선택: 실생활에선 고정된, 정의된 상수 (공개 키)
        4. d는 e의 역원 *모듈러(mod)* 파이n값 계산 (공개 키에 대응하는 비밀 키): a mod b(a를 b로 나눈 나머지 반환) / d도 약 2000비트 길이<br>

2. RSA 서명 생성 및 검증 과정
    1. X = 선택한 메시지
    2. 서명값 s = sig_k(X) = X의 d제곱 mod n (x의 d제곱을 n으로 나눈 나머지)
    3. 서명 검증 v = ver_k(x, x의 d제곱) = s의 e제곱 mod n = x(메시지): 공개 키를 이용해 서명값에서 메시지 뽑아냄->최초 메시지와 같은지 비교-> 같으면 true 반환(검증 성공)<br>

- 즉 선택한 키를 가지고 `지수 연산(exponentiation)`을 통해 서명 생성 및 검증 수행
- 개인 키 d + 메시지 -> 지수연산 ->서명값 s 생성->서명값 s의 공개키 e로 메시지 복구->복구한 메시지가 받은 메시지 및 서명값에 붙어 온 메시지와 같은지 검증
- RSA: 서명 생성, 검증과정 뒤집으면 *암복호화(encryption and decryption)* 과정이 된다.<br>

### 2. RSA 암복호화
- 암호화: 무언가를 아무나 이해할 수 없도록 감추기 (공개 키 사용)
- 복호화: 감춰진 메시지를 복구해서 내용을 열람하기 (개인 키 사용)<br>


# 블록체인과 전자서명
## 메시지 부가형 전자서명
### 1. 대표적인 '메시지 부가형' 전자서명 2가지
1. RSA 전자서명
    - 1978년 라이베스타(Rivest), 세미어(Shamir), 아델만(Adleman) 세 명 이름 앞 글자를 따서 RSA
    - 지수 연산을 통해 서명값 생성 + 지수 연산을 통해 서명 검증
    - 모듈러(mod, moduler)연산 사용: A mod B = A를 B로 나눈 나머지 값 사용
    - 현실에서 모듈러 값 약 **2000비트** 사용 중: 그런데 메시지도 서명값에 붙여야 함->크기 너무 커짐
    - 검증값 길이 제한 => 가능한 메시지도 제한됨 => 메시지 길이 고정 위해 `해시함수` 이용=> 메시지 해시값 사용
    - RSA 단점 (->타원곡선 암호 제안)
        1. 필요한 데이터 값이 크다
        2. 각 약 2000비트하는 소수 p, q(개인 키 값)를 생성하는 데에도 시간이 많이 들어간다.
        3. 계산장비의 발달에 따라 사용하는 값은 더 커질 수 밖에 없는데, 효율성이 떨어진다.<br>

2. 타원곡선 전자서명 (ECDSA, Elliptic Curve Digital Signature Algorithm)
    - 1985년 밀러와 코블리츠가 제안
    - 타원곡선 연산을 통해 만들어내는 전자서명 기법: ECDSA, 타원곡선 전자서명 알고리즘<br>

### 2. RSA 전자서명
- 소수 p, q를 모르는 상황에서 pq = n의 n값을 알아도 p, q값을 찾기 어려운 인수분해 문제를 기반으로 한다.
- 공개 키 n, e / 개인 키 p, q, d

![RSA_1](https://user-images.githubusercontent.com/54266900/67000294-884d8d80-f112-11e9-8e35-881db585d1cd.PNG)

1. 서명 생성 과정: 메시지 m, 개인키 d 사용
    1. 메시지 m을 해시해서 해시값 H 생성
    2. 난수 k 생성: 여러 번 서명 시 값이 다 다르게 하기 위함
    3. 지수연산: (해시값 H에 난수 k값 조합해 랜덤화된 수를 d승) mod 공개키 n = 서명값 S 생성
    4. 서명 생성: m(원본메시지) || S (서명값)<br>

![RSA_2](https://user-images.githubusercontent.com/54266900/67000592-1295f180-f113-11e9-9628-114d9298625a.PNG)

2. 서명 검증 과정: m || S, 공개 키 e 사용
    1. 받은 원본메시지 m 해시한 값 H 생성
    2. 지수연산: (서명값 S에 공개 키 e승) mod 공개키 n = 메시지 해시값 H' 계산
    3. 원본메시지 해시값 H와 지수연산으로 생성한 H' 같은지 비교 -> 같으면 검증 성공<br>


### 3. 타원곡선 전자서명(ECDSA) (직접 조사한 내용 추가함)
- 타원곡선 이산대수 문제 기반
- 타원곡선이란?  {\displaystyle y^{2}=x^{3}+ax+b}y^{2}=x^{3}+ax+b 형태의 방정식으로 정의되는 대수 곡선으로 첨점이나 교차점 등의 특이점이 없는 것 (출처 위키백과)
- 타원곡선 암호(Elliptic Curve Cryptography, ECC): 타원곡선 이론에 기반한 공개 키 암호 방식
- 알려진 특정한 점에 대한 무작위 타원 곡선의 **이산 로그({\displaystyle a^{x}=b}를 만족하는 {\displaystyle x}x)**를 찾는 것이 오래걸린다는 점에서 착안
- P, Q가 타원곡선 상의 한 점일 때 dP = Q 식에서 P, Q 값을 알아도 d를 찾기 어려운 것을 기반으로 한다.
- 따라서 d가 개인 키, Q가 공개 키가 된다.

![ECDSA_1](https://user-images.githubusercontent.com/54266900/67001378-8b497d80-f114-11e9-908e-0433b1fb9cf0.PNG)

1. 서명 생성 과정: 메시지 m, 개인 키 d 사용
    1. 메시지 m을 해시해서 해시값 H 생성
    2. 난수 k 생성: 여러 번 서명 시 값이 다 다르게 하기 위함
    3. 타원 곡선 연산: 공개된 값 P*k 연산해서 타원 곡선 위 점 (x, y) 생성 -> 점의 x좌표 값 r 생성 = 첫 번째 서명값
    4. 정수 연산: 난수 k, 메시지해시값 H, 첫번째 서명값 r, 개인 키 d 등 조합해서 모듈러 연산 -> 두 번째 서명값 s 생성
    5. 최종 서명값: 원본메시지 m || (r, s)<br>

![ECDSA_2](https://user-images.githubusercontent.com/54266900/67001714-52f66f00-f115-11e9-8b03-5fadbf07e262.PNG)

2. 서명 검증 과정: m || (r,s)와 공개 키 Q사용
    1. 받은 원본메시지 m 해시한 값 H 생성
    2. 타원곡선 연산: Q = dP로 치환 -> kP를 계산하는 의미 -> r' 값 추출
    3. 서명값 r과 연산한 값 r' 비교 -> 같으면 검증 성공<br>


## 비트코인에서의 전자서명
### 1. 계좌 생성
- 공개 키 기반 전자서명: 사용자가 선택한 개인키에 대응하는 공개 키 존재
- 공개 키 = 계좌번호
- 개인 키: 계좌 소유권 주장 및 검증<br>

- 계좌 생성 과정 (타원곡선 암호의 경우)
    1. 나만 아는 개인키 d 랜덤 생성
    2. 타원곡선 연산 dP = Q = (x, y): 공개 키 Q 생성
    3. 이 때 공개 키 Q는 x, y 각 200~250 비트-> 총 500비트
    4. 500비트 공개 키 해시: 바이너리 값
    5. 해시한 바이너리 값 인코딩 (아스키 등 인간이 식별 가능한 형태로) -> 계좌로 사용<br>

### 2. 거래 승인 및 검증
- 공개 키는 계좌번호 역할
- 정당한 사용자가 개인 키로 서명하여 거래 승인
- 전자서명 특성에 의해 거래 내용(메시지), 공개 키, 전자서명 값을 이용해 누구나 검증 가능<br>

- 거래 승인 및 검증 과정 
    1. 거래 승인: 개인 키, 거래내용(메시지)->서명 생성
    2. 거래 검증: 서명값, 거래내용(메시지), 공개 키로 서명 검증<br>

- `개인`과 `개인 키`<->`공개 키` 연결? 신뢰할 수 있는 제 3의 기관이 검증 수행 -> 인증서 발급<br>


![알기쉬운블록체인_마인드맵_8주차](https://user-images.githubusercontent.com/54266900/67003517-16c50d80-f119-11e9-83d8-c651c0d6fef6.jpg)




 