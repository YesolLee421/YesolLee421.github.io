---
title: "[블록체인] 6주차_블록체인과 암호기술"
categories:
  - BlockChain
  - 블록체인
comments : true
---
*이 내용은 K-MOOC [알기쉬운블록체인] 강의를 듣고 정리한 내용입니다.*
<br>

[알기쉬운블록체인]: http://www.kmooc.kr/courses/course-v1:SJCU+SJCU01+2019_2/courseware/145ba5714d1246c1b65fe1b081d52db0/e1af1659e74343579fe5727acdfcfbc7/?child=last

<br>

# 데이터의 신뢰성
## 디지털 데이터의 신뢰성이란?
### 1. 디지털 데이터의 특징
- 디지털 데이터란? 컴퓨터가 이해할 수 있는 언어로 변조해서(`부호화`,`encoding`) 디지털 형태로 가공된 정보
- 복제 용이->변조, 변경 용이
- '원본에 대한 신뢰성을 어떻게 확보할 수 있을까?'
- 대부분 양이 방대 & `비가독성` (컴퓨터가 이해할 수 있는 고유 언어로 부호화되어 인간이 이해하기 힘듦)<br>

### 2. 디지털 데이터의 신뢰성
- 원본에 대한 복제가 굉장히 용이하니 사본을 쉽게 만들 수 있다.
- 사본이 원본과 값이 같으면 사본 또한 원본이 된다.
- 즉 '원본' 이라는 의미는 '변조되지 않았음'을 의미함
- A, B 중 어느 것이 원본인가?
  - 두 데이터를 위에서부터 순차적으로 전부 비교: 양이 적을 때 가능
  - 그러나 양이 많으면?<br>


### 3. 매우 큰 두 디지털 데이터 비교하기: 검증값 (validation value)
- 주어진 원본값에 대한 검증값이 주어지고, 해당 값을 공개함
- 용량 큰 프로그램 다운 받을 때, 원본 프로그램과 동일한지 확인하는 절차
- 프로그램 다운받은 후, 원본 프로그램의 연산을 통해 계산한 검증값과 원본 사이트에서 공개한 검증값과 비교해서 변조되지 않았음을 식별함
- 같은 계산과정(프로그램)이라면 같은 입력값에 대해 같은 출력값(검증값)을 내보냄
- 장점: 전체 데이터에 비해 검증값은 일정한 크기의 작은 값이 되도록 유지
- 따라서 디지털 데이터: `디지털데이터` + `검증값`<br>

### 4. 검증값 예시: 통신 상 오류 검출을 위한 CRC 값
- 통신 상 오류 발생해서 발신자가 전달한 데이터나 메시지가 수신자에게 도착했을 때 일부 변조가 일어날 가능성이 있다ㅏ.
- 이런 오류를 검출하기 위해 패킷(packit) 정보 뒤에 CRC값을 많이 붙인다.
- CRC (Cyclic Redundancy Check)
- 통신 상 오류를 빠르게 검출하기 위해 사용하는 검증값
- 검증: 패킷 수신자는 패킷으로부터 유도된(계산된) CRC 값과 패킷 뒤에 붙어 온 CRC 값을 비교함으로서 '원본 패킷이 잘 왔는가?'를 검증함<br>

- 그러나 CRC 값 만으로 `무결성`을 주장하기엔 부족함: 패킷과 CRC 값이 이미 주어 진 상황에서 변조시킨 패킷이 우연히 동일한 CRC 값을 내놓을 경우 있음
- 따라서 실제 검증값: 주어 진 입력값 변조해서 유효한 CRC 값을 만들기 어렵도록 설계하는 것이 주요 이슈<br>

## 데이터와 검증값
### 1. 데이터로 검증값 만드는 합리적 방법
- 검증값: 주어진 데이터를 가지고 **어떠한 과정**을 통해 가공한 출력값
- 함수: 검증값을 만들어내는 과정
- `입력값` (디지털 데이터) -> `함수`(계산과정) -> `검증값`(가공된 출력값)<br>

### 2. 함수의 역할
- 검증값: 방대한 원본 데이터보다 작아서 비교하기 쉽고 빠름
- 원본 데이터가 같으면 같은 검증값 출력해야 검증의 유효성 확인 가능<br>

1. 입력 데이터를 축약한다.
2. 동일한 입력값이 들어가면 동일한 출력값이 나온다.<br>

- 함수에 들어갈 입력 및 출력의 크기
  - 입력값: 무한대의 입력값 가능
  - 출력값: 입력값 길이와 상관 없이 동일한 길이의 출력값 필요
  - 예시) 자연수를 받아서 일정 길이의 검증값 출력하기
    1. 입력값: 자연수 전체 집합 (무한대 가능)
    2. 함수: 입력값을 *13으로 나눴을 때 나머지 값 계산*
    3. 출력값: 0부터 12까지 정수만 가능 = 즉 **고정 길이**<br>

  - 실제 CRC 값: 대부분 32비트 다항식(`기약다항식`)으로 데이터를 나눴을 때의 나머지로 데이터 축약 -> 즉 32비트의 어떤 비트값이 검증값이 됨
  - 예시와 같이 *'13으로 나눈 나머지값'* 같은 함수는 특정 검증값을 도출할 입력값을 찾기가 굉장히 쉽다.
  - 따라서 *'검증값을 만드는 함수를 어떻게 설계할 것인가'* 고민할 필요가 있다.<br>

### 3. 데이터와 검증값
1. 검증값은 충분히 작은 길이로 축약되어야 함
2. 비교적 빠르게 계산되어야 함
3. 검증값으로부터 입력 데이터를 유추하기 어려워야 함
4. 검증값을 가지는 데이터를 만들기 어려워야 함
=> 암호 기술 `해시함수` 등장<br>


## 해시함수의 개념
### 1. 검증값 (validation value) 사용
- 위, 변조 여부 검증 및 무결성 검증 가능하게 하려면? *주어진 `검증값`에 대한 입력값을 쉽게 유도할 수 없게 해야 한다.'*
-> `해시함수(Hash function)` 등장
- 예시) 재판에서 증거의 해시값이 다르다는 이유로 증거가 조작될 가능성이 있다는 판례<br>

### 2. 해시 함수란?
- 임의의 입력을 받아 고정된 길이의 출력값을 내는 함수
- 계산의 용이성 반드시 필요: 임의의 길이를 가지는 입력값이기 때문에 굉장히 큰 값이 들어올 수 있다는 것을 전제로 함수가 동작해야 한다.
- 그러나 결과값이 너무 작으면? 동일한 `검증값`을 내는 `입력값` 너무 쉽게 유추 가능하면 안됨<br>


### 충돌(Collision)
- 다른 입력값에 대해 동일한 출력값을 내는 상황
- 임의 길이의 입력을 받아 *압축, 고정된 길이의 결과값*을 내기 때문에 어쩔 수 없이 충돌 가능성 있음
- 충돌 100% 방지는 불가능하지만, 이 충돌되는 상황을 찾기 굉장히 어렵게 설계함<br>

## 해시함수의 성질
### 1. 충돌 저항성 (Collision Resistance)
- 동일한 출력값을 내 놓는 서로 다른 입력값 찾는 것이 어렵도록 (*계산상 불가능하도록*) 설계된 함수
- *'계산 상 불가능하다?'* 의 의미: 충분히 긴 길이의 해시값을 가져서 현재, 혹은 근미래의 컴퓨터의 계산 능력으로 천문학적인 시간이 걸리는 수준. 현 시대 컴퓨터의 연산 능력에 기준하기 때문에 미래 더 고성능의 기계가 나오면 의미가 변할 수 있음.
- 기계 연산 능력 발전에 따라 해시함수 결과물이 계속 길어지고 있음
  1. `MD5` 해시함수: 128비트 결과값
  2. `SHA1` 해시함수: 2010년 이전 주로 사용, 160비트 결과값
  3. `SHA256` 해시함수: 256비트 결과값 (현재 권장되는 출력값은 224비트)<br>


### 2. 역상 저항성 (Preimage Resistance)
- 역상(Preimage)이란? Pre + image(함수의 결과값): 즉 함수 결과값(image)에 대응하는 입력값이 Preimage이다.
- 역상 저항성이란?
  - 주어진 해시값(결과값)에 대응하는 입력값을 찾기 어렵게 설계된 성질
  - 검증값으로부터 입력값인 x를 찾는 것이 *계산 상 불가능하다*
- 충돌 저항성과 비슷하게 실제 입력값 x를 찾는다고 해도 해당 값의 `데이터 형식`까지 알아내긴 힘들다. (문서, 이미지파일, 동영상 등)<br>


### 3. 제2 역상 저항성 (Seconde Preimage Resistance)
- 해시함수의 입력값이 x, 출력값이 y라고 할 때 같은 출력값 y를 만들어내는 다른 입력값 x'를 찾는 게 계산 상 불가능하다.<br>

- 충돌 저항성, 역상 저항성, 제2 역상 저항성의 성질을 모두 가진 해시함수를 설계하면 충분히 무결성을 담보할 수 있게 된다.<br>
