---
title: "[블록체인] 9주차_거래 정보의 구조"
categories:
  - BlockChain
tags:
  - BlockChain
  - 블록체인
  - K-MOOC

comments : true
---
*이 내용은 K-MOOC [알기쉬운블록체인] 강의를 듣고 정리한 내용입니다.*
<br>

[알기쉬운블록체인]: http://www.kmooc.kr/courses/course-v1:SJCU+SJCU01+2019_2/courseware/145ba5714d1246c1b65fe1b081d52db0/e1af1659e74343579fe5727acdfcfbc7/?child=last

<br>

# 거래 정보의 구성
## 블록체인이 풀어야 할 문제
### 1. 도서관의 도서 일람표 카드로 비유한 블록체인
- 분류방식: 저자 일람표(저자 이름순), 제목 일람표(제목 순), 출판일자 순
- 알람표 = 한 권의 책에 대한 정보: 저자 이름, 책 제목, 출판일, 책 위치, 고유 식별자

### 2. 블록체인의 목표
- 목표: 전체 거래 이력(transaction)을 순서대로 유지하는 것
- 해결할 문제
    1. 거래 정보를 발생 순서대로 유지
    2. 변경을 바로 감지하여 조작(manipulate), 위조(forge, counterfeit) 방지
- 해결 방법
    1. 거래 정보의 도서관 만들기
    2. 거래가 추가된 순서대로 정렬
    3. 모든 변경(알람표 순서, 개별 거래 정보 등)을 감지할 수 있도록 `해시값`으로 연결<br>

## 책의 변환: 책 구조를 블록체인으로 변환하기
### 1. 책의 구조
1. 내용: 각 페이지 단위로 내용 보관
2. 정렬
    - 책의 모든 페이지 정렬
    - 각 페이지 내 문장이 내용 순으로 정렬
3. 페이지의 연결
    - 물리적으로 책에 연결됨 (책등에 순서대로 붙어있음)
    - 논리적으로 내용-페이지 번호로 연결

### 2. 책의 변환 6단계
1. 페이지 의존성(dependency) 확보
    - 한 페이지: `페이지 번호` + `내용`
    - 페이지 번호: 페이지의 누락(omission)이나 중복(duplication), 순서바뀜(reversed)을 쉽게 확인<br>

2. 페이지 연결
    - 페이지 번호에 규칙성이 없는 경우? 페이지 누락, 중복 등을 확인하기 위한 방법 필요
    - 각 페이지가 바로 앞 페이지 번호 가짐: 전후관계 생성<br>

3. 페이지 내용 아웃소싱(페이지번호 / 내용 분리)
    - 페이지번호는 사이즈 일정, 하지만 내용은 임의 사이즈 -> 분리
    - 내용을 페이지 밖에 둠으로써 책은 오로지 순서 유지에 집중
    - 책 -> 내용 일람표 역할: 내용 고유 참조 값 가짐
    - 내용: 고유 참조 값(reference value)로 식별되는 별도 페이지에 저장
    - 내용 일부의 위조 여부를 알기 위해서 조치 필요<br>

4. 페이지 번호를 참조 값으로 대체
    - 자연수 -> 해시값을 페이지 참조값으로 사용<br>

5. 페이지 참조 값 생성 방법
    - 암호화 해시값 사용: 입력값 길이에 상관없이 출력값 길이는 일정
    - 페이지 내용 해시 + 페이지 번호 + 앞 페이지 번호 => 하나의 해시값 생성
    - 페이지 번호 참조 값 및 내용 참조값을 모두 해시값으로 사용하면 위조 쉽게 발견 가능
    - 페이지 내용 및 페이지 순서 변경 불가<br>

6. 파본
    - 페이지 내용 및 순서 변경 불가 & 참조값으로 찾기 가능
    - 즉 제본된 상태일 필요 없이 페이지 섞어도 순서 정보 유지
    - 순서 일람표의 **마지막 페이지**만 알고 있으면 이전 페이지 참조값 따라서 전체 페이지 순서 및 연결 구조 알 수 있음
    - 페이지 포함 내용 = 자기 페이지 참조값 + 이전 페이지 참조값 + 내용 페이지 참조값<br>

### 3. 블록체인-데이터-구조

| 성질 | 변환 전 책 | 변환 후 책 |
|:---:|:---|:---|
| 내용 저장 | 페이지 자체 | 별도 내용페이지 + 고유 참조값 |
| 페이지 연결 | 물리적&논리적(페이지 번호) | 논리적(참조값) | 
| 페이지 검색 | 전방&후방&직접 접근 가능 | 후방만 가능(직전페이지 참조값 따라가기) |

![9_1_3_변환전후책비교](https://user-images.githubusercontent.com/54266900/67277121-148bf600-f501-11e9-945d-a32072b1d7f0.PNG)

1. 순서일람표 페이지 -> 블록 헤더
2. 전체 순서 일람표 -> 블록 헤더의 체인
    - 참조를 통해 선형으로 연결됨
3. 순서일람표 페이지 참조값 -> 블록헤더의 암호화 해시값
4. 직전 페이지 참조값 -> 직전 블록헤더의 암호화 해시값
5. 내용 -> 트랜잭션 데이터(거래 기록)
    - 블록체인은 사실 *내용 페이지*가 별개로 존재하지 않음
    - 거래 정보들이 한 블록 단위가 아닌 전체 내용이 DB 같은데 저장됨
    - 논리적 `머클 트리`생성: 해당 머클트리 루트가 각 블록헤더에 저장
6. 내용 페이지 -> 트랜잭션 데이터 가진 머클 트리
7. 내용 페이지 참조값 -> 트랜잭션 데이터 가진 머클 트리 루트
8. 순서일람표 페이지+해당 내용 페이지 -> `블록체인-데이터-구조`의 한 블록
9. 전체 순서일람표+전체 내용 -> `블록체인-데이터-구조`<br>


# 거래 정보의 추가
## Hash 함수 (Hash function)
### 1. 블록체인을 이해하기 위한 두 가지 질문
1. 정보의 대조: 두 개 이상의 정보를 대조해서 전체 정보가 서로 같은지 다른지 판별
2. 체인의 구성요소: 이전 블록을 알 수 있도록 이전 블록에 대한 참조값(주소) 필요 => 결론: `해시` 필요<br>

### 2. 블록체인에서 Hash 함수의 역할
1. 정보의 요약: 임의 길이의 입력값을 고정 길이의 출력값으로 변환
2. 정보의 확인: 같은 입력값이면 같은 출력값(해시값) -> 즉 원본 아닌 해시값만 비교 가능
3. 정보의 연결
    - 자연수 페이지번호: 이전 페이지 내용과 이전 페이지 번호는 서로 상관이 없다.
    - 해시값: 이전 페이지 전체에 대한 해시값 -> 이전 페이지 내용이 바뀌면 쉽게 알 수 있음<br>

### 3. Hash 함수의 성질
1. 입력이 같으면 출력도 동일
2. 입력이 조금만 달라도 출력이 달라짐
3. 출력으로부터 입력 추정 불가
    - 2번 성질로 인해(입력이 조금만 달라도 출력이 아주 달라짐) 출력값만 가지고 입력값을 추정해 볼 여지가 전혀 없다.
    - 예시) 주민등록번호나 우편번호: 쉽게 알아낼 수 있는 여러 정보를 담고 있음 / 비슷한 숫자의 의미를 알면 다른 번호도 유추할 가능성이 있음
    - 해시값: 비슷한 해시값의 의미를 알게 되어도 그걸 참고해서 다른 해시값 내용 알아낼 수 없음
    - 위조도 어려움: 해시값으로 내용 알아내기 힘드니 어느 부분을 조작할지도 알기 힘듦<br>


## Hashing Patterns
### 1. Hash 함수 적용 방법: 여러 개의 데이터에 대한 해시값 생성
1. 독립 해싱: 서로 다른 데이터를 독립적으로 각각 해싱 ("Hello" -> 해시값1, "World!" -> 해시값2)
2. 반복 해싱: 해싱한 결과값을 다시 해싱 ("Hello" -> 해시값1 -> 해시값2)
3. 결합 해싱: 데이터 먼저 결합한 전체 결과를 해싱 ("Hello" + "World!" = "Hello World!" -> 해시값1)<br>

4. 순차적 해싱
    - 첫 번째 데이터 해싱 후 다음 데이터가 들어오면 해시값과 데이터 합친 값을 다시 해싱하는 식으로 차례대로 결합하는 방식 ("Hello" -> 해시값1 + "World!" -> "해시값1 World!" -> 해시값2 ...)
    - 결합 해싱과 반복 해싱이 동시에 일어남<br>

5. 계층적 해싱
    - 모든 개별 데이터 가각 해싱한 다음 해시값을 모아서 다시 해시하는 방식으로 계층적으로 데이터를 모으는 방식 ("Hello" -> 해시값1, "World!" -> 해시값2, 해시값1 + 해시값2 -> 해시값3 (전체데이터 계층의 루트))
    - 최종적으로 하나의 해시값이 남을 때까지 반복 -> 해시트리의 루트
    - 결합 해싱과 반복 해싱이 동시에 일어남
    - 블록체인에서 사용하는 `머클트리`의 구조<br>


## 거래정보의 저장
### Transaction 저장 방법
- 하나의 블록에 저장되는 transaction이 여러 개일 수 있다. -> 여러 정보를 고정된 사이즈 정보 만들어야 함
- transactio들을 모아 `Merkle Tree(머클트리)` 구성
- 각 트랜잭션 정보 해싱 -> 계층적 해싱 -> 루트 해시값(=전체 내용 요약)을 `블록헤더`에 저장 -> 블록 하나 생성
- 여러 개의 블록일 경우?

![9_2_3_트랜잭션저장](https://user-images.githubusercontent.com/54266900/67459920-a700d680-f674-11e9-8874-3258daec2f27.PNG)

- 두 번째 이상 블록부터: 이전 블록 헤더 해시값(이전 블록 참조값) +  해당 블록내용 요약 해시값(트랜잭션 데이터 머클트리 루트 해시값)
- 마지막 블록헤더의 해시값을 최종적으로 가짐 -> 해당 해시값 역으로 따라가면 모든 블록에 접근 가능<br>









