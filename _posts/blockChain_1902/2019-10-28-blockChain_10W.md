---
title: "[블록체인] 10주차_블록의 생성 1"
categories:
  - BlockChain
tags:
  - BlockChain
  - 블록체인
  - K-MOOC

comments : true
---
*이 내용은 K-MOOC [알기쉬운블록체인] 강의를 듣고 정리한 내용입니다.*
<br>

[알기쉬운블록체인]: http://www.kmooc.kr/courses/course-v1:SJCU+SJCU01+2019_2/courseware/145ba5714d1246c1b65fe1b081d52db0/e1af1659e74343579fe5727acdfcfbc7/?child=last

<br>

# 거래 정보의 보호
## 정보 조작의 문제
### 1. 위조 방지 방법
- '불가능'은 아니지만 극단적으로 많은 비용과 노력이 필요해서 사실상 위조 어렵게 하기
- 블록체인 목표: transaction 이력을 변경할 수 없게 만들어서 위조나 조작 방지
- 해결할 문제: 개방된 분산 P2P 시스템의 부정직한 peer들의 위조 시도로부터 정보 보호<br>

### 2. 블록체인의 위조 방지 방법
- 개방된 시스템에서 정직한 node와 부정직한 node를 사전에 구분하는 것은 불가능
- 따라서 애초에 그 누구도 transaction 정보를 조작할 수 없도록 만듦
- transaction 이력을 변경, 위조하는 일이 너무나 큰 노력과 비용이 들어가서 단념하게 됨
- '불변성' = `읽기 전용(readOnly)`
- 모든 종류의 증명서에 해당: 운전면허증, 여권, 졸업증명서 등<br>

## 불변성 구현 메카니즘
### 1. 블록체인 위조 방지를 위한 조건 3가지
1. 조작이 쉽게 드러나게 만듦
    - `블록체인-데이터-구조`에서 변경-감지 방식으로 저장됨
    - 사소한 변경도 hash참조를 손상시켜 쉽게 감지됨
2. 변경된 데이터를 끼워넣으려먼 블록을 다시 작성하도록 강제함
    - 변경하려면 해당 블록부터 체인의 마지막 블록까지 모두 변경해야 함
3. data를 추가, 변경, 재작성하는 작업에 엄청난 비용이 발생하게 만듦
    - 각 블록 작성 시 블록헤더마다 고유하게 존재하는 `hash puzzle` 풀어야 하므로 엄청난 계산 비용 발생<br>

### 2. 불변성을 위한 세 가지 고려사항
1. `block header`의 필수 데이터
    - transaction (거래 내용) 데이터 담고 있는 Merkle tree의 root
    - 이전 block header를 가리키는 hash 참조값
    - hash puzzle의 난이도: (블록헤더 해시값 계산에 포함)난이도를 임의로 낮추어 계산량 줄이는 것 방지
    - hash puzzle 풀이 시작 시간: 해시퍼즐 푸는 데 걸리는 시간 측정해서 블록체인 전체의 해시퍼즐 난이도 조절함
    - hash puzzle을 해결할 수 있는 nonce(난스값): 블록헤더 해시할 때 난스값도 포함하는데, 해시한 값이 특정 조건을 만족하도록 만드는 특정 값이 난스값이 된다. 해시값으로 입력값 찾기 어려움으로 여러 가지 난스값을 하나씩 넣어보며 조건에 맞는 값을 찾는 것이 과제가 된다. (작업 증명, proof of work)<br>

2. 새 `block header` 생성하는 과정
    1. 새로 추가되는 transaction 담고 있는 Merkle tree의 root얻기
    2. 직전 block header를 가리키는 hash 참조 생성
    3. 필요한 난이도 획득: 블록체인 전체에서 일정 시간 간격으로 난이도 조절됨
    4. 현재 시간 확인: 시간도 블록헤더 데이터에 추가됨
    5. 1~4의 정보를 포함하는 에비 블록헤더 생성
    6. 예비 블록헤더에 해당하는 해시퍼즐 계산
    7. 해시 퍼즐을 해결하는 난스(nonce)fmf 예비 블록헤더에 포함시켜 새 블록 완성
        - 블록 생성 시, 풀어야 할 hash puzzle: 난이도도 해시의 일부가 되기 때문에 난이도를 쉽게 조정하는 행위도 쉽게 발각된다.
        ![10_1_2_해시퍼즐](https://user-images.githubusercontent.com/54266900/67662424-b64e8f80-f9a6-11e9-8e51-3667476506ef.PNG)
        
3. 블록헤더 검증 규칙: 해시퍼즐 해결하고, 필요한 계산 비용을 지불한 블록만 추가될 수 있도록 보장함
    1. 직전 블록을 가리키는 유효한 hash참조를 가지고 있어야 한다.
    2. transaction 데이터를 담고 있는 Merkle tree의 root 포함
    3. 정확한 난이도
    4. time stamp가 직전 블록헤더의 time stamp 이후여야 한다. (블록 및 거래내용이 추가된 순서대로 정렬되어 있음을 보장)
    5. nonce값 포함
    6. 앞의 다섯 개 data 조각을 합친 hash값으로 난이도 충족해야 함<br>

## 메카니즘 분석
### 1. 해당 메커니즘이 작동하는 이유
- 사소한 변화로도 해시값이 변하기 때문
- data의 사소한 변경 -> hash참조값 불일치 -> 영향 받는 모든 블록 재작성-> 엄청난 계산량으로 조작 포기<br>

### 2. 현재 head로부터 20 block 이전의 한 transaction을 조작하려는 경우
1. 조작된 transaction data가 속한 Merkle tree를 재작성
2. 재작성 된 merkle tree의 root가 속한 블록 헤더를 재작성
    - hash puzzle을 다시 풀어야 함
3. 해당 블록부터 연결된 모든 후속 블록헤더들을 재작성
    - 20개의 블록 헤더 재작성 (hash puzzle 포함)<br>

### 3. 불변성을 결정하는 Hash Puzzle의 난이도
- 해시퍼즐 어려울수록 조작 가능성 낮아짐
- 퍼즐 너무 쉬울 때: 적은 시간과 노력으로 조작이 가능해 조작을 부추김
- 퍼즐 너무 어려울 때: 블록 생성에 많은 비용이 소요되어 참여 node가 감소함
- 새 블록이 추가되는 속도에 따라 난이도 동적 조절
    - 기준치: (Bitcoin) 2016개의 블록 생성에 2주가 걸리는지 체크 (10분에 블록 1개 생성)
    - 하나의 블록 추가하는 데 걸리는 시간이 기준치보다 길면(어려우면) 난이도 감소, 기준치보다 짧으면(쉬우면) 난이도 증가<br>
