---
title: "[블록체인] 10주차_블록의 생성 1"
categories:
  - BlockChain
tags:
  - BlockChain
  - 블록체인
  - K-MOOC

comments : true
---
*이 내용은 K-MOOC [알기쉬운블록체인] 강의를 듣고 정리한 내용입니다.*
<br>

[알기쉬운블록체인]: http://www.kmooc.kr/courses/course-v1:SJCU+SJCU01+2019_2/courseware/145ba5714d1246c1b65fe1b081d52db0/e1af1659e74343579fe5727acdfcfbc7/?child=last

<br>

# 거래 정보의 보호
## 정보 조작의 문제
### 1. 위조 방지 방법
- '불가능'은 아니지만 극단적으로 많은 비용과 노력이 필요해서 사실상 위조 어렵게 하기
- 블록체인 목표: transaction 이력을 변경할 수 없게 만들어서 위조나 조작 방지
- 해결할 문제: 개방된 분산 P2P 시스템의 부정직한 peer들의 위조 시도로부터 정보 보호<br>

### 2. 블록체인의 위조 방지 방법
- 개방된 시스템에서 정직한 node와 부정직한 node를 사전에 구분하는 것은 불가능
- 따라서 애초에 그 누구도 transaction 정보를 조작할 수 없도록 만듦
- transaction 이력을 변경, 위조하는 일이 너무나 큰 노력과 비용이 들어가서 단념하게 됨
- '불변성' = `읽기 전용(readOnly)`
- 모든 종류의 증명서에 해당: 운전면허증, 여권, 졸업증명서 등<br>

## 불변성 구현 메카니즘
### 1. 블록체인 위조 방지를 위한 조건 3가지
1. 조작이 쉽게 드러나게 만듦
    - `블록체인-데이터-구조`에서 변경-감지 방식으로 저장됨
    - 사소한 변경도 hash참조를 손상시켜 쉽게 감지됨
2. 변경된 데이터를 끼워넣으려먼 블록을 다시 작성하도록 강제함
    - 변경하려면 해당 블록부터 체인의 마지막 블록까지 모두 변경해야 함
3. data를 추가, 변경, 재작성하는 작업에 엄청난 비용이 발생하게 만듦
    - 각 블록 작성 시 블록헤더마다 고유하게 존재하는 `hash puzzle` 풀어야 하므로 엄청난 계산 비용 발생<br>

### 2. 불변성을 위한 세 가지 고려사항
1. `block header`의 필수 데이터
    - transaction (거래 내용) 데이터 담고 있는 Merkle tree의 root
    - 이전 block header를 가리키는 hash 참조값
    - hash puzzle의 난이도: (블록헤더 해시값 계산에 포함)난이도를 임의로 낮추어 계산량 줄이는 것 방지
    - hash puzzle 풀이 시작 시간: 해시퍼즐 푸는 데 걸리는 시간 측정해서 블록체인 전체의 해시퍼즐 난이도 조절함
    - hash puzzle을 해결할 수 있는 nonce(난스값): 블록헤더 해시할 때 난스값도 포함하는데, 해시한 값이 특정 조건을 만족하도록 만드는 특정 값이 난스값이 된다. 해시값으로 입력값 찾기 어려움으로 여러 가지 난스값을 하나씩 넣어보며 조건에 맞는 값을 찾는 것이 과제가 된다. (작업 증명, proof of work)<br>

2. 새 `block header` 생성하는 과정
    1. 새로 추가되는 transaction 담고 있는 Merkle tree의 root얻기
    2. 직전 block header를 가리키는 hash 참조 생성
    3. 필요한 난이도 획득: 블록체인 전체에서 일정 시간 간격으로 난이도 조절됨
    4. 현재 시간 확인: 시간도 블록헤더 데이터에 추가됨
    5. 1~4의 정보를 포함하는 에비 블록헤더 생성
    6. 예비 블록헤더에 해당하는 해시퍼즐 계산
    7. 해시 퍼즐을 해결하는 난스(nonce)fmf 예비 블록헤더에 포함시켜 새 블록 완성
        - 블록 생성 시, 풀어야 할 hash puzzle: 난이도도 해시의 일부가 되기 때문에 난이도를 쉽게 조정하는 행위도 쉽게 발각된다.
        ![10_1_2_해시퍼즐](https://user-images.githubusercontent.com/54266900/67662424-b64e8f80-f9a6-11e9-8e51-3667476506ef.PNG)
        
3. 블록헤더 검증 규칙: 해시퍼즐 해결하고, 필요한 계산 비용을 지불한 블록만 추가될 수 있도록 보장함
    1. 직전 블록을 가리키는 유효한 hash참조를 가지고 있어야 한다.
    2. transaction 데이터를 담고 있는 Merkle tree의 root 포함
    3. 정확한 난이도
    4. time stamp가 직전 블록헤더의 time stamp 이후여야 한다. (블록 및 거래내용이 추가된 순서대로 정렬되어 있음을 보장)
    5. nonce값 포함
    6. 앞의 다섯 개 data 조각을 합친 hash값으로 난이도 충족해야 함<br>

## 메카니즘 분석
### 1. 해당 메커니즘이 작동하는 이유
- 사소한 변화로도 해시값이 변하기 때문
- data의 사소한 변경 -> hash참조값 불일치 -> 영향 받는 모든 블록 재작성-> 엄청난 계산량으로 조작 포기<br>

### 2. 현재 head로부터 20 block 이전의 한 transaction을 조작하려는 경우
1. 조작된 transaction data가 속한 Merkle tree를 재작성
2. 재작성 된 merkle tree의 root가 속한 블록 헤더를 재작성
    - hash puzzle을 다시 풀어야 함
3. 해당 블록부터 연결된 모든 후속 블록헤더들을 재작성
    - 20개의 블록 헤더 재작성 (hash puzzle 포함)<br>

### 3. 불변성을 결정하는 Hash Puzzle의 난이도
- 해시퍼즐 어려울수록 조작 가능성 낮아짐
- 퍼즐 너무 쉬울 때: 적은 시간과 노력으로 조작이 가능해 조작을 부추김
- 퍼즐 너무 어려울 때: 블록 생성에 많은 비용이 소요되어 참여 node가 감소함
- 새 블록이 추가되는 속도에 따라 난이도 동적 조절
    - 기준치: (Bitcoin) 2016개의 블록 생성에 2주가 걸리는지 체크 (10분에 블록 1개 생성)
    - 하나의 블록 추가하는 데 걸리는 시간이 기준치보다 길면(어려우면) 난이도 감소, 기준치보다 짧으면(쉬우면) 난이도 증가<br>


    
# 거래 정보의 전파
## 정보 전달 문제
### 1. 문제의 정의
- 블록체인: 트랜잭션 데이터 전체 이력이 저장된 원장을 보유한 개별 컴퓨터(full-node)로 구성
- full-node: 블록체인 전체 거래 이력 가지고 있는 개별 컴퓨터
- 각 node: 자신의 경험에 따라 트랜잭션이 발생했는지 증언하는 목격자와 같음
- 순수 분산 P2P 시스템에는 중앙 통제 장치 없음 = 정보 공유를 위한 중간자가 없음
- 해결 과제: 중간자에 의지하지 않고 모든 노드가 모든 트랜잭션 정보를 주고받을 수 있도록 보장해야 한다.<br>

### 2. 순수 분산 P2P 시스템에서 노드 간 정보 전달 방식: 소문 확산
- 각 node가 주변의 몇몇 노드들에게 정보 전달
- 정보를 전달받은 노드는 또 자기 주변의 다른 노드에 이를 전달<br>

### 3. 목적에 따른 의사소통 유형 세 가지
1. 잡담: 정보를 담고 있지는 않지만 관계 유지가 목적
2. 소식: 구성원들 간 중요 관심사에 대한 정보 전달 -> 블록체인-데이터-구조에 새로운 트랜잭션, 블록 추가
3. 새로운 동료 소개: 이미 형성된 집단에 새로운 구성원 추가 -> 블록체인 네트워크에 새로운 노드 추가<br>


## 정보 전달 메카니즘
### 1. P2P 시스템의 특징
1. 각 노드는 인터넷을 통해 연결: 반드시 네트워크 연결되어 있어야 한다.
2. 각 노드는 고유 주소로 식별됨: URL과 다른 블록체인 고유 주소 체계 존재
3. 각 노드는 언제는 시스템(인터넷)에서 분리될수도, 재접속 할 수도 있다.
4. 각 노드는 통신하는 `peer list`를 독립적으로 유지함: 직접 통신하는 node들이 정해져 있다.
5. 각 노드 간 통신은 `message`를 통해 이루어짐
6. 인터넷 상의 메시지는 각 노드에 부여된 고유 주소를 통해 노드 간 일대일 전송됨: 즉 `브로드캐스팅(전체 시스템 방송)`이 아니라 `일대일 통신`<br>

### 2. P2P 시스템 상에서 정보 전달의 특징
1. 목적지에 도달한다는 보장이 없음
    - 네트워크 통신: 언제든지 단절, 재접속 가능성 있음
    - message 소실 가능
2. 중복해서 전달될 수 있음: 여러 가지 경로(여러 노드에서 통신)로 전달하기 때문
3. 보낸 순서와 다른 순서로 도착할 수 있음: 늦게 보내도 더 짧은 경로를 거쳐 온 메시지가 먼저 도착할 수도 있음<br>

### 3. 통신 장애 해결 방법
1. `message`는 소문 형식으로 전달
    - `message`를 받은 node는 자신의 peer들에게 전달
    - 부분적으로 `message`가 소실될 수 있지만 중복해서 전달함으로써 결국 모든 node에게 전달되는 것을 보장함
2. `message`는 암호화 hash값으로 식별 가능
    - 중복되어 전달된 `message`쉽게 식별하고 버릴 수 있음
3. `message`는 시간에 따라 정렬됨
    - 트랜잭션 데이터와 블록헤더는 `time stamp`를 포함 ->시간 순 정렬 가능<br>

### 4. P2P 시스템에서 node간 통신의 세 가지 유형
1. 기존 연결 유지
    - 각 노드는 통신하는 `peer list`를 독립적으로 유지
    - `peer list`는 시스템을 구성하는 전체 node Set의 부분집합
    - 각 노드는 주기적으로 peer들이 접속 상태인지 확인한다
        - **Ping Pong message`** 사용: 'Ping' 보내서 'Pong'오면 접속 상태로 간주
        - 일정 시간 이상 접속하지 않는 peer는 리스트에서 제거한다.<br>

2. 새로운 노드 연결
    - 시스템에 새로 참여하려는 node는 임의의 node에게 접속 요청 전달
    - 요청 받은 node가 응답하면 두 node는 서로 peer list에 상대방 추가
    - 같은 방법으로 다수의 노드를 peer list에 추가하여 강건한 network 형성<br>

3. 새로운 정보 배포: 새로운 트랜잭션이나 블록을 추가<br>


### 5. 정보 공유의 세 가지 유형: 소유권 관리 위해 협업하는 과정
1. 지속적인 방식: 새로운 `트랜잭션`과 `블록`은 발생 동시에 배포
2. 갱신 방식: 시스템의 한 노드가 연결 끊어졌다가 재접속 했을 때 그동안 발생한 `트랜잭션`, `블록` 정보를 다른 피어로부터 전달받는 것
3. `on-boarding`절차의 일부: 시스템에 새로 참여한 node의 경우 처음부터 지금까지 발생한 모든 트랜잭션 이력을 한꺼번에 전달받아 `블록체인-데이터-구조`를 컴퓨터에 구축하는 것<br>

### 6. 통신 메카니즘 분석
- 새로운 node가 시스템에 참여할 수 있도록 보장함: 시스템 확장 가능
- 기존 연결 유지, 관리
- `블록체인-데이터-구조`에 새로 추가할 정보 자기 피어에 전달-> 결국 정보를 모든 노드에 전달하도록 보장함<br>